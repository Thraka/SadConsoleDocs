---
title: 'Create a SadConsole game: Part 5 - Object handling'
description: Learn how to create different types of map objects that react to the player touching them. Part 5 of the SadConsole getting started series.
---

import { Steps } from '@astrojs/starlight/components';
import { SaveFile } from "starlight-save-file-component";


In this part of the tutorial, you learn how to add different types of map objects that react differently to the player touching them.

Previous articles in this tutorial:

- [Part 1 - Drawing](/tutorials/first-game/part-1-drawing/)
- [Part 2 - Cursors and parenting](/tutorials/first-game/part-2-cursor-parents/)
- [Part 3 - Input](/tutorials/first-game/part-3-input/)
- [Part 4 - A proper map](/tutorials/first-game/part-4-mapobject/)

## Prerequisites

This part of the tutorial continues where the previous one left off. If you don't have your code handy, you can download it now.

<SaveFile title="Download starting project" href="/article-assets/files/tutorials/first-game/part4.zip" />

## Concrete types

The `GameObject` type represents a thing that can be positioned and drawn on the map. However, it doesn't really "do" anything. Create two new classes, one for **monster** and one for **treasure**. Both inherit from `GameObject` and override the `Touched` method.

### Treasure

To create the treasure class, perform the following:

<Steps>
01. Add a new class to the project, named _Treasure.cs_.
01. Open the code file and replace the code with the following snippet:

    ```csharp
    namespace SadConsoleGame;

    internal class Treasure: GameObject
    {

    }
    ```

01. In the class declaration, add a new constructor that calls the base class's constructor. This sets the appearance of the "treasure" object.

    ```csharp
    public Treasure(Point position, IScreenSurface hostingSurface)
        : base(new ColoredGlyph(Color.Yellow, Color.Black, 'v'), position, hostingSurface)
    {

    }
    ```

    Unlike instantiating a normal `GameObject` type, where you must specify how the game object looks, `Treasure` always looks like "treasure" in the game. This is because the constructor for `Treasure` specifies the `ColoredGlyph` used by the game object. You can specify any other defaults in the constructor too, though there aren't any yet.

01. Next, add the code for the `Touched` method. Note that the `map.RemoveMapObject` method doesn't yet exist.

    ```csharp
    public override bool Touched(GameObject source, Map map)
    {
        // Is the player the one that touched us?
        if (source == map.UserControlledObject)
        {
            map.RemoveMapObject(this);
            return true;
        }

        return false;
    }
    ```

    The previous code checks if the player, `UserControlledObject`, is the one that touched this treasure. If it was, the object is removed from the map and `true` is returned, which lets the player move into that space.
</Steps>

Treasure is finished, but the `RemoveMapObject` method on the map doesn't exist. You create that after the `Monster` type is created.

### Monster

To create the monster class, perform the following:

<Steps>
01. Add a new class to the project, named _Monster.cs_.
01. Open the code file and replace the code with the following snippet:

    ```csharp
    namespace SadConsoleGame;

    internal class Monster : GameObject
    {

    }
    ```

01. In the class declaration, add a new constructor that calls the base class's constructor.

    ```csharp
    public Monster(Point position, IScreenSurface hostingSurface)
        : base(new ColoredGlyph(Color.Red, Color.Black, 'M'), position, hostingSurface)
    {

    }
    ```

    Just like `Treasure`, `Monster` specifies the `ColoredGlyph` for every `Monster` type. You can introduce variation later, but for now, they'll all be `M` on the screen.

01. Next, add the code for the `Touched` method.

    ```csharp
    public override bool Touched(GameObject source, Map map)
    {
        return base.Touched(source, map);
    }
    ```
</Steps>

## Update the map with RemoveMapObject

The map needs to expose the ability to remove an object from itself. This is the `RemoveMapObject` method.

<Steps>
01. Open the _Map.cs_ file.
01. Add the following code:

    ```csharp
    public void RemoveMapObject(GameObject mapObject)
    {
        if (_mapObjects.Contains(mapObject))
        {
            _mapObjects.Remove(mapObject);
            mapObject.RestoreMap(this);
        }
    }
    ```
</Steps>

This code checks if the game object is associated with the map, and if it is, removes it. Notice the call to `mapObject.RestoreMap`. When a game object moves, it restores the map space before drawing itself to the new map space. You need to expose that capability so that when you remove a game object from the map, it can restore the map's space.

## Update the game object with RestoreMap

Next, add the `RestoreMap` method to the `GameObject` class. This lets external objects, such as the map, tell the game object to fill back in the old map space.

<Steps>
01. Open the _GameObject.cs_ file.
01. Add the following code:

    ```csharp
    public void RestoreMap(Map map) =>
        _mapAppearance.CopyAppearanceTo(map.SurfaceObject.Surface[Position]);
    ```

    This code uses another modern C# technique, the `=>` expression operator. When you declare a method and only have a single code statement, you can omit the `{ }` block and use the expression operator to infer the single code statement as the body of the method.
</Steps>

## Use the new treasure and monster classes

The map has the `CreateTreasure` and `CreateMonster` methods, but they currently use the `GameObject` class. Modify these two methods to use the concrete types.

<Steps>
01. Open the _Map.cs_ file.
01. Change the code in the `CreateTreasure` method. Alter the type used when creating the treasure instance:

    From:

    ```csharp
    GameObject treasure = new GameObject(new ColoredGlyph(Color.Yellow, Color.Black, 'v'), randomPosition, _mapSurface);
    ```

    To:

    ```csharp
    Treasure treasure = new Treasure(randomPosition, _mapSurface);
    ```

    Note that the constructor parameters changed. The `Treasure` type doesn't require a `ColoredGlyph` to describe how it looks.

01. Next, change the code in the `CreateMonster` method in the same way as `CreateTreasure`:

    From:

    ```csharp
    GameObject monster = new GameObject(new ColoredGlyph(Color.Red, Color.Black, 'M'), randomPosition, _mapSurface);
    ```

    To:

    ```csharp
    Monster monster = new Monster(randomPosition, _mapSurface);
    ```
</Steps>

## Run the game

Before you run the game to test out touching the treasure and monster, add more monsters and treasure to the map. The map has two methods, `CreateTreasure` and `CreateMonster`, which are both called once in the map's constructor. Call them five times instead, which makes the map a little more populated.

<Steps>
01. Open the _Map.cs_ file.
01. Find the `Map` constructor and add a `for` loop that runs five times.

    ```csharp
    public Map(int mapWidth, int mapHeight)
    {
        _mapObjects = new List<GameObject>();
        _mapSurface = new ScreenSurface(mapWidth, mapHeight);
        _mapSurface.UseMouse = false;

        FillBackground();

        UserControlledObject = new GameObject(new ColoredGlyph(Color.White, Color.Black, 2), _mapSurface.Surface.Area.Center, _mapSurface);

        for (int i = 0; i < 5; i++)
        {
            CreateTreasure();
            CreateMonster();
        }
    }
    ```

01. Run the game.
</Steps>

Now you'll see that there are multiple treasure objects. Walk the player into them and notice that they disappear. Do the same with monsters and notice that they remain.

![Player moving around and picking up treasure.](/article-assets/images/tutorials/first-game/part-5-more-objects/treasure_pickup.gif)

## Conclusion

The game is starting to come together, with game objects and a map object that ties everything together. In the next part of the series, you'll explore how to add more consoles to the screen to present status and information to the player.


- Next: Get Started 6 - .... Not yet ready

<SaveFile title="Download example project" href="/article-assets/files/tutorials/first-game/part5.zip" />
